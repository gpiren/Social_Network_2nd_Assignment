dice_mat    <- similarity(graph_reduced, method = "dice")
jaccard_mat <- similarity(graph_reduced, method = "jaccard")
aa_mat      <- similarity(graph_reduced, method = "invlogweighted")
# 3) Combine into one data.frame with class labels
metrics <- bind_rows(
mutate(positive_class, class = 1),
mutate(negative_class, class = 0)
)
# 4) Compute Common Neighbours (undo Dice normalization)
metrics$common_neighbors <- mapply(function(u, v) {
dice_mat[u, v] * (degree(graph_reduced, u) + degree(graph_reduced, v)) / 2
}, metrics$from, metrics$to)
# 5) Compute Jaccard
metrics$jaccard <- mapply(function(u, v) {
jaccard_mat[u, v]
}, metrics$from, metrics$to)
# 6) Compute Adamic–Adar
metrics$adamic_adar <- mapply(function(u, v) {
aa_mat[u, v]
}, metrics$from, metrics$to)
# 7) Check your first rows
print(head(metrics))
knitr::opts_chunk$set(echo = TRUE)
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(stringr)
library(dplyr)
library(archive)
library(ggraph)
library(tidygraph)
library(ggrepel)
library(extrafont)
library(tibble)
library(fmsb)
library(GGally)
library(tidyr)
marvel_nodes <- read.csv("data/nodes.csv", stringsAsFactors = FALSE,
quote = "\"", fill = TRUE)
marvel_links <- read.csv("data/edges.csv", stringsAsFactors = FALSE)
# to get proper x and y coordinates
marvel_nodes$x_cor <- as.numeric(str_extract(marvel_nodes$X_pos,
"-?\\d+\\.\\d+"))
marvel_nodes$y_cor <- as.numeric(str_extract_all(marvel_nodes$X_pos,
"-?\\d+\\.\\d+") %>%
sapply(`[`, 2))
# we don't need the X_pos anymore
marvel_nodes$X_pos <- NULL
marvel_nodes <- marvel_nodes |>
rename(id = X..index,
character_name = name) |>
mutate(id = id + 1) # for best indexing practice
marvel_nodes <- marvel_nodes |>
mutate(character_name = str_replace_all(character_name, "/", " ")) |>
mutate(character_name = str_trim(str_replace(character_name, "^(\\w+),\\s*([\\w\\s]+)$", "\\2 \\1"))) |>
mutate(character_name = str_replace_all(character_name, "[^[:alnum:]\\s]", ""))
marvel_links <- marvel_links |>
rename(source = X..source,
target = target)
marvel_links <- marvel_links |>
mutate(source = source + 1,
target = target + 1)
network_graph <- graph_from_data_frame(d = marvel_links, vertices = marvel_nodes, directed = FALSE)
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph,
vertex.label = NA,
vertex.size = 2,
vertex.color = "red",
edge.color = "black",
edge.width = 0.5,
layout = layout)
V(network_graph)$id <- marvel_nodes$id  # explicitly set id attribute
set.seed(123)
par(mar=c(0,0,0,0), mfrow=c(1,3))
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.color="black", edge.width=0.5, layout=layout)
# Delete 15% of edges
edges <- as_data_frame(network_graph, what = "edges")
remove_frac <- 0.15
remove_edges <- sample(1:ecount(network_graph), size = round(remove_frac * ecount(network_graph)))
positive_class <- edges[remove_edges, c("from", "to")]
E(network_graph)$color <- "black"
E(network_graph)$color[remove_edges] <- "gray"
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# Create negative class and plot reduced graph
graph_reduced <- delete_edges(network_graph, remove_edges)
sample_non_edges <- function(gr, n) {
non_edges <- data.frame(from = integer(), to = integer())
while (nrow(non_edges) < n) {
v1 <- sample(vcount(gr), 1)
v2 <- sample(vcount(gr), 1)
if (v1 != v2 && !are_adjacent(gr, v1, v2)) {
non_edges <- rbind(non_edges, data.frame(from = v1, to = v2))
}
}
non_edges
}
negative_class <- sample_non_edges(graph_reduced, nrow(positive_class))
E(graph_reduced)$color <- "black"
plot(graph_reduced, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
print(ecount(network_graph))      # orijinal kenar sayısı
print(ecount(graph_reduced))
# after
dice_mat    <- similarity(graph_reduced, method="dice")
jaccard_mat <- similarity(graph_reduced, method="jaccard")
aa_mat      <- similarity(graph_reduced, method="invlogweighted")
# add these lines:
cat("Number of non-zero Dice entries:   ", sum(dice_mat    > 0), "\n")
cat("Number of non-zero Jaccard entries:", sum(jaccard_mat > 0), "\n")
cat("Number of non-zero AA entries:     ", sum(aa_mat      > 0), "\n")
summary(metrics$common_neighbors)
summary(metrics$jaccard)
summary(metrics$adamic_adar)
max(metrics$common_neighbors)
max(metrics$jaccard)
max(metrics$adamic_adar)
nonzero <- which(metrics$common_neighbors > 0)
head(metrics[nonzero, ], 10)
View(metrics)
knitr::opts_chunk$set(echo = TRUE)
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(stringr)
library(dplyr)
library(archive)
library(ggraph)
library(tidygraph)
library(ggrepel)
library(extrafont)
library(tibble)
library(fmsb)
library(GGally)
library(tidyr)
library(caret)
marvel_nodes <- read.csv("data/nodes.csv", stringsAsFactors = FALSE,
quote = "\"", fill = TRUE)
marvel_links <- read.csv("data/edges.csv", stringsAsFactors = FALSE)
# to get proper x and y coordinates
marvel_nodes$x_cor <- as.numeric(str_extract(marvel_nodes$X_pos,
"-?\\d+\\.\\d+"))
marvel_nodes$y_cor <- as.numeric(str_extract_all(marvel_nodes$X_pos,
"-?\\d+\\.\\d+") %>%
sapply(`[`, 2))
# we don't need the X_pos anymore
marvel_nodes$X_pos <- NULL
marvel_nodes <- marvel_nodes |>
rename(id = X..index,
character_name = name) |>
mutate(id = id + 1) # for best indexing practice
marvel_nodes <- marvel_nodes |>
mutate(character_name = str_replace_all(character_name, "/", " ")) |>
mutate(character_name = str_trim(str_replace(character_name, "^(\\w+),\\s*([\\w\\s]+)$", "\\2 \\1"))) |>
mutate(character_name = str_replace_all(character_name, "[^[:alnum:]\\s]", ""))
network_graph <- graph_from_data_frame(d = marvel_links, vertices = marvel_nodes, directed = FALSE)
knitr::opts_chunk$set(echo = TRUE)
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(stringr)
library(dplyr)
library(archive)
library(ggraph)
library(tidygraph)
library(ggrepel)
library(extrafont)
library(tibble)
library(fmsb)
library(GGally)
library(tidyr)
library(caret)
marvel_nodes <- read.csv("data/nodes.csv", stringsAsFactors = FALSE,
quote = "\"", fill = TRUE)
marvel_links <- read.csv("data/edges.csv", stringsAsFactors = FALSE)
# to get proper x and y coordinates
marvel_nodes$x_cor <- as.numeric(str_extract(marvel_nodes$X_pos,
"-?\\d+\\.\\d+"))
marvel_nodes$y_cor <- as.numeric(str_extract_all(marvel_nodes$X_pos,
"-?\\d+\\.\\d+") %>%
sapply(`[`, 2))
# we don't need the X_pos anymore
marvel_nodes$X_pos <- NULL
marvel_nodes <- marvel_nodes |>
rename(id = X..index,
character_name = name) |>
mutate(id = id + 1) # for best indexing practice
marvel_nodes <- marvel_nodes |>
mutate(character_name = str_replace_all(character_name, "/", " ")) |>
mutate(character_name = str_trim(str_replace(character_name, "^(\\w+),\\s*([\\w\\s]+)$", "\\2 \\1"))) |>
mutate(character_name = str_replace_all(character_name, "[^[:alnum:]\\s]", ""))
marvel_links <- marvel_links |>
rename(source = X..source,
target = target)
marvel_links <- marvel_links |>
mutate(source = source + 1,
target = target + 1)
network_graph <- graph_from_data_frame(d = marvel_links, vertices = marvel_nodes, directed = FALSE)
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph,
vertex.label = NA,
vertex.size = 2,
vertex.color = "red",
edge.color = "black",
edge.width = 0.5,
layout = layout)
V(network_graph)$id <- marvel_nodes$id  # explicitly set id attribute
marvel_nodes <- read.csv("data/nodes.csv", stringsAsFactors = FALSE,
quote = "\"", fill = TRUE)
marvel_links <- read.csv("data/edges.csv", stringsAsFactors = FALSE)
# to get proper x and y coordinates
marvel_nodes$x_cor <- as.numeric(str_extract(marvel_nodes$X_pos,
"-?\\d+\\.\\d+"))
marvel_nodes$y_cor <- as.numeric(str_extract_all(marvel_nodes$X_pos,
"-?\\d+\\.\\d+") %>%
sapply(`[`, 2))
# we don't need the X_pos anymore
marvel_nodes$X_pos <- NULL
marvel_nodes <- marvel_nodes |>
rename(id = X..index,
character_name = name) |>
mutate(id = id + 1) # for best indexing practice
marvel_nodes <- marvel_nodes |>
mutate(character_name = str_replace_all(character_name, "/", " ")) |>
mutate(character_name = str_trim(str_replace(character_name, "^(\\w+),\\s*([\\w\\s]+)$", "\\2 \\1"))) |>
mutate(character_name = str_replace_all(character_name, "[^[:alnum:]\\s]", ""))
marvel_links <- marvel_links |>
rename(source = X..source,
target = target)
marvel_links <- marvel_links |>
mutate(source = source + 1,
target = target + 1)
# Fixing the Marvel dataset: it's actually a bipartite network
# Characters are connected to comic books, not directly to each other
# Step 1: Load the original bipartite graph
bipartite_graph <- graph_from_data_frame(marvel_links, vertices = marvel_nodes, directed = FALSE)
# Step 2: Tag node types (TRUE = comic book, FALSE = character)
# According to the original paper: first 6486 nodes = characters
V(bipartite_graph)$type <- V(bipartite_graph)$id > 6486
vertex_attr_names(bipartite_graph)
# Create the bipartite graph
bipartite_graph <- graph_from_data_frame(marvel_links, vertices = marvel_nodes, directed = FALSE)
# Tag first 6486 nodes as characters (FALSE), rest as comic books (TRUE)
V(bipartite_graph)$type <- seq_along(V(bipartite_graph)) > 6486
# Create character-character projection
projections <- bipartite_projection(bipartite_graph)
head(marvel_links)
library(igraph)
library(dplyr)
# Only keep proper bipartite edges: one from each type
marvel_links_bip <- marvel_links %>%
filter((source <= 6486 & target > 6486) | (source > 6486 & target <= 6486))
# Recreate graph with only valid bipartite edges
bipartite_graph <- graph_from_data_frame(marvel_links_bip, vertices = marvel_nodes, directed = FALSE)
# Tag nodes: FALSE = character, TRUE = comic book
V(bipartite_graph)$type <- seq_along(V(bipartite_graph)) > 6486
# Perform projection: character-character network
projections <- bipartite_projection(bipartite_graph)
network_graph <- projections$proj1  # This is your final graph
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph,
vertex.label = NA,
vertex.size = 2,
vertex.color = "red",
edge.color = "black",
edge.width = 0.5,
layout = layout)
V(network_graph)$id <- marvel_nodes$id  # explicitly set id attribute
set.seed(123)
par(mar=c(0,0,0,0), mfrow=c(1,3))
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.color="black", edge.width=0.5, layout=layout)
# deleting 15% of edges
edges <- as_data_frame(network_graph, what = "edges")
remove_frac <- 0.15
remove_edges <- sample(1:ecount(network_graph), size = round(remove_frac * ecount(network_graph)))
positive_class <- edges[remove_edges, c("from", "to")]
E(network_graph)$color <- "black"
E(network_graph)$color[remove_edges] <- "gray"
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# creating a negative class and plot reduced graph
graph_reduced <- delete_edges(network_graph, remove_edges)
sample_non_edges <- function(gr, n) {
non_edges <- data.frame(from = integer(), to = integer())
while (nrow(non_edges) < n) {
v1 <- sample(vcount(gr), 1)
v2 <- sample(vcount(gr), 1)
if (v1 != v2 && !are_adjacent(gr, v1, v2)) {
non_edges <- rbind(non_edges, data.frame(from = v1, to = v2))
}
}
non_edges
}
negative_class <- sample_non_edges(graph_reduced, nrow(positive_class))
E(graph_reduced)$color <- "black"
plot(graph_reduced, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# After projection: character-character network
# network_graph is already created via bipartite_projection
layout <- layout_with_fr(network_graph)  # since x_cor/y_cor no longer valid here
plot(network_graph,
vertex.label = NA,
vertex.size = 2,
vertex.color = "red",
edge.color = "black",
edge.width = 0.5,
layout = layout)
set.seed(123)
par(mar=c(0,0,0,0), mfrow=c(1,3))
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.color="black", edge.width=0.5, layout=layout)
# deleting 15% of edges
edges <- as_data_frame(network_graph, what = "edges")
remove_frac <- 0.15
remove_edges <- sample(1:ecount(network_graph), size = round(remove_frac * ecount(network_graph)))
positive_class <- edges[remove_edges, c("from", "to")]
E(network_graph)$color <- "black"
E(network_graph)$color[remove_edges] <- "gray"
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# creating a negative class and plot reduced graph
graph_reduced <- delete_edges(network_graph, remove_edges)
sample_non_edges <- function(gr, n) {
non_edges <- data.frame(from = integer(), to = integer())
while (nrow(non_edges) < n) {
v1 <- sample(vcount(gr), 1)
v2 <- sample(vcount(gr), 1)
if (v1 != v2 && !are_adjacent(gr, v1, v2)) {
non_edges <- rbind(non_edges, data.frame(from = v1, to = v2))
}
}
non_edges
}
negative_class <- sample_non_edges(graph_reduced, nrow(positive_class))
E(graph_reduced)$color <- "black"
plot(graph_reduced, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# making sure our positive/negative classes are integers
positive_class <- positive_class %>%
mutate(from = as.integer(from),
to   = as.integer(to))
negative_class <- negative_class %>%
mutate(from = as.integer(from),
to   = as.integer(to))
# precomputing ALL three similarity matrices on the reduced graph
dice_mat    <- similarity(graph_reduced, method = "dice")
jaccard_mat <- similarity(graph_reduced, method = "jaccard")
aa_mat      <- similarity(graph_reduced, method = "invlogweighted")
# combining all
metrics <- bind_rows(
mutate(positive_class, class = 1),
mutate(negative_class, class = 0)
)
# for the common neighbours
metrics$common_neighbors <- mapply(function(u, v) {
dice_mat[u, v] * (degree(graph_reduced, u) + degree(graph_reduced, v)) / 2
}, metrics$from, metrics$to)
metrics$jaccard <- mapply(function(u, v) {
jaccard_mat[u, v]
}, metrics$from, metrics$to)
metrics$adamic_adar <- mapply(function(u, v) {
aa_mat[u, v]
}, metrics$from, metrics$to)
metrics
knitr::opts_chunk$set(echo = TRUE)
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(stringr)
library(dplyr)
library(archive)
library(ggraph)
library(tidygraph)
library(ggrepel)
library(extrafont)
library(tibble)
library(fmsb)
library(GGally)
library(tidyr)
library(caret)
marvel_nodes <- read.csv("data/nodes.csv", stringsAsFactors = FALSE,
quote = "\"", fill = TRUE)
marvel_links <- read.csv("data/edges.csv", stringsAsFactors = FALSE)
# to get proper x and y coordinates
marvel_nodes$x_cor <- as.numeric(str_extract(marvel_nodes$X_pos,
"-?\\d+\\.\\d+"))
marvel_nodes$y_cor <- as.numeric(str_extract_all(marvel_nodes$X_pos,
"-?\\d+\\.\\d+") %>%
sapply(`[`, 2))
# we don't need the X_pos anymore
marvel_nodes$X_pos <- NULL
marvel_nodes <- marvel_nodes |>
rename(id = X..index,
character_name = name) |>
mutate(id = id + 1) # for best indexing practice
marvel_nodes <- marvel_nodes |>
mutate(character_name = str_replace_all(character_name, "/", " ")) |>
mutate(character_name = str_trim(str_replace(character_name, "^(\\w+),\\s*([\\w\\s]+)$", "\\2 \\1"))) |>
mutate(character_name = str_replace_all(character_name, "[^[:alnum:]\\s]", ""))
marvel_links <- marvel_links |>
rename(source = X..source,
target = target)
marvel_links <- marvel_links |>
mutate(source = source + 1,
target = target + 1)
View(marvel_links)
# Only keep proper bipartite edges: one from each type
marvel_links_bip <- marvel_links %>%
filter((source <= 6486 & target > 6486) | (source > 6486 & target <= 6486))
View(marvel_links_bip)
library(igraph)
library(dplyr)
# Only keep proper bipartite edges: one from each type
marvel_links_bip <- marvel_links %>%
filter((source <= 6486 & target > 6486) | (source > 6486 & target <= 6486))
# Recreate graph with only valid bipartite edges
bipartite_graph <- graph_from_data_frame(marvel_links_bip, vertices = marvel_nodes, directed = FALSE)
# Tag nodes: FALSE = character, TRUE = comic book
V(bipartite_graph)$type <- seq_along(V(bipartite_graph)) > 6486
# Perform projection: character-character network
projections <- bipartite_projection(bipartite_graph)
network_graph <- projections$proj1  # This is your final graph
# After projection: character-character network
# network_graph is already created via bipartite_projection
layout <- layout_with_fr(network_graph)  # since x_cor/y_cor no longer valid here
plot(network_graph,
vertex.label = NA,
vertex.size = 2,
vertex.color = "red",
edge.color = "black",
edge.width = 0.5,
layout = layout)
set.seed(123)
par(mar=c(0,0,0,0), mfrow=c(1,3))
layout <- as.matrix(marvel_nodes[, c("x_cor", "y_cor")])
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.color="black", edge.width=0.5, layout=layout)
# deleting 15% of edges
edges <- as_data_frame(network_graph, what = "edges")
remove_frac <- 0.15
remove_edges <- sample(1:ecount(network_graph), size = round(remove_frac * ecount(network_graph)))
positive_class <- edges[remove_edges, c("from", "to")]
E(network_graph)$color <- "black"
E(network_graph)$color[remove_edges] <- "gray"
plot(network_graph, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# creating a negative class and plot reduced graph
graph_reduced <- delete_edges(network_graph, remove_edges)
sample_non_edges <- function(gr, n) {
non_edges <- data.frame(from = integer(), to = integer())
while (nrow(non_edges) < n) {
v1 <- sample(vcount(gr), 1)
v2 <- sample(vcount(gr), 1)
if (v1 != v2 && !are_adjacent(gr, v1, v2)) {
non_edges <- rbind(non_edges, data.frame(from = v1, to = v2))
}
}
non_edges
}
negative_class <- sample_non_edges(graph_reduced, nrow(positive_class))
E(graph_reduced)$color <- "black"
plot(graph_reduced, vertex.label=NA, vertex.size=2, vertex.color="red", edge.width=0.5, layout=layout)
# making sure our positive/negative classes are integers
positive_class <- positive_class %>%
mutate(from = as.integer(from),
to   = as.integer(to))
negative_class <- negative_class %>%
mutate(from = as.integer(from),
to   = as.integer(to))
# precomputing ALL three similarity matrices on the reduced graph
dice_mat    <- similarity(graph_reduced, method = "dice")
jaccard_mat <- similarity(graph_reduced, method = "jaccard")
aa_mat      <- similarity(graph_reduced, method = "invlogweighted")
# combining all
metrics <- bind_rows(
mutate(positive_class, class = 1),
mutate(negative_class, class = 0)
)
# for the common neighbours
metrics$common_neighbors <- mapply(function(u, v) {
dice_mat[u, v] * (degree(graph_reduced, u) + degree(graph_reduced, v)) / 2
}, metrics$from, metrics$to)
metrics$jaccard <- mapply(function(u, v) {
jaccard_mat[u, v]
}, metrics$from, metrics$to)
metrics$adamic_adar <- mapply(function(u, v) {
aa_mat[u, v]
}, metrics$from, metrics$to)
head(metrics,10)
View(metrics)
# preferential attachment (product of degrees)
metrics$pref_attach <- mapply(function(u, v) {
from_idx <- which(V(network_graph)$id == u)
to_idx <- which(V(network_graph)$id == v)
if (length(from_idx) == 0 || length(to_idx) == 0) return(0)
degree(network_graph, from_idx) * degree(network_graph, to_idx)
}, metrics$from, metrics$to)
# Check results for preferential attachment
head(metrics %>% select(-common_neighbors, -jaccard, -adamic_adar))
head(V(network_graph)$id)
head(network_graph)
View(network_graph)
V(network_graph)$name <- as.character(marvel_nodes$id)
V(network_graph)$name <- as.character(V(network_graph))  # ID olarak ata
metrics$pref_attach <- mapply(function(u, v) {
u <- as.character(u)
v <- as.character(v)
if (u %in% V(network_graph)$name & v %in% V(network_graph)$name) {
degree(network_graph, v = u) * degree(network_graph, v = v)
} else {
0
}
}, metrics$from, metrics$to)
head(metrics %>% select(-common_neighbors, -jaccard, -adamic_adar))
